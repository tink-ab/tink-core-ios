// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name TinkCore
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Dispatch
import Foundation
import OSLog
import Security
import Swift
import UIKit
import _Concurrency
import _StringProcessing
public struct AccessToken : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(_ value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct Account {
  public enum Kind : Swift.CaseIterable {
    case checking
    case savings
    case investment
    case mortgage
    case creditCard
    case loan
    case pension
    case other
    case external
    case unknown
    public static func == (a: TinkCore.Account.Kind, b: TinkCore.Account.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public typealias AllCases = [TinkCore.Account.Kind]
    public static var allCases: [TinkCore.Account.Kind] {
      get
    }
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum AccountExclusion {
    case aggregation
    case pfmAndSearch
    case pfmData
    case unknown
    public static func == (a: TinkCore.Account.AccountExclusion, b: TinkCore.Account.AccountExclusion) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias ID = TinkCore.Identifier<TinkCore.Account>
  public let accountNumber: Swift.String
  public let credentialsID: TinkCore.Credentials.ID
  public let isFavorite: Swift.Bool
  public let id: TinkCore.Account.ID
  public let name: Swift.String
  public let ownership: Swift.Double
  public let kind: TinkCore.Account.Kind
  public let transferSourceIdentifiers: [Foundation.URL]?
  public let holderName: Swift.String?
  public let isClosed: Swift.Bool?
  public let accountExclusion: TinkCore.Account.AccountExclusion?
  public let currencyDenominatedBalance: TinkCore.CurrencyDenominatedAmount?
  public let refreshed: Foundation.Date?
  public let firstSeen: Foundation.Date?
  public let financialInstitutionID: TinkCore.Provider.FinancialInstitution.ID?
  public init(id: TinkCore.Account.ID, credentialsID: TinkCore.Credentials.ID, name: Swift.String, accountNumber: Swift.String, kind: TinkCore.Account.Kind, transferSourceIdentifiers: [Foundation.URL]?, holderName: Swift.String?, isClosed: Swift.Bool?, currencyDenominatedBalance: TinkCore.CurrencyDenominatedAmount?, refreshed: Foundation.Date?, firstSeen: Foundation.Date?, financialInstitutionID: TinkCore.Provider.FinancialInstitution.ID?, isFavorite: Swift.Bool = false, ownership: Swift.Double = 1.0, accountExclusion: TinkCore.Account.AccountExclusion = .unknown)
}
extension TinkCore.Account : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.Account, b: TinkCore.Account) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AccountService {
  func accounts(completion: @escaping (Swift.Result<[TinkCore.Account], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func update(id: TinkCore.Account.ID, name: Swift.String?, type: TinkCore.Account.Kind?, accountNumber: Swift.String?, isFavorite: Swift.Bool?, ownership: Swift.Double?, accountExclusion: TinkCore.Account.AccountExclusion?, completion: @escaping (Swift.Result<TinkCore.Account, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct ActionableInsight {
  public typealias ID = TinkCore.Identifier<TinkCore.ActionableInsight>
  public struct InsightAction {
    public let label: Swift.String?
    public let data: TinkCore.InsightActionData?
    public init(label: Swift.String?, data: TinkCore.InsightActionData?)
  }
  @frozen public enum State {
    case active([TinkCore.ActionableInsight.InsightAction])
    case archived(Foundation.Date)
  }
  public enum Kind {
    case accountBalanceLow(TinkCore.ActionableInsight.AccountBalanceLowData)
    case budgetOverspent(TinkCore.ActionableInsight.BudgetSummary)
    case budgetCloseNegative(TinkCore.ActionableInsight.BudgetSummary)
    case budgetClosePositive(TinkCore.ActionableInsight.BudgetSummary)
    case budgetSuccess(TinkCore.ActionableInsight.BudgetSummary)
    case budgetSummaryAchieved(TinkCore.ActionableInsight.BudgetPeriodSummary)
    case budgetSummaryOverspent(TinkCore.ActionableInsight.BudgetPeriodSummary)
    case largeExpense(TinkCore.ActionableInsight.LargeExpense)
    case singleUncategorizedTransaction(TinkCore.Transaction.ID)
    case doubleCharge([TinkCore.Transaction.ID])
    case weeklyUncategorizedTransactions(TinkCore.ActionableInsight.WeeklyTransactions)
    case weeklySummaryExpensesByCategory(TinkCore.ActionableInsight.WeeklyExpensesByCategory)
    case weeklySummaryExpensesByDay(TinkCore.ActionableInsight.WeeklyExpensesByDay)
    case monthlySummaryExpensesByCategory(TinkCore.ActionableInsight.MonthlyExpensesByCategory)
    case weeklySummaryExpenseTransactions(TinkCore.ActionableInsight.WeeklyTransactionsSummary)
    case monthlySummaryExpenseTransactions(TinkCore.ActionableInsight.MonthlyTransactionsSummary)
    case newIncomeTransaction(TinkCore.ActionableInsight.NewIncomeTransaction)
    case suggestSetUpSavingsAccount(TinkCore.ActionableInsight.SuggestSetUpSavingsAccount)
    case creditCardLimitClose(TinkCore.ActionableInsight.CreditCardLimit)
    case creditCardLimitReached(TinkCore.ActionableInsight.CreditCardLimit)
    case leftToSpendPositiveMidMonth(TinkCore.ActionableInsight.LeftToSpendMidMonth)
    case leftToSpendNegativeMidMonth(TinkCore.ActionableInsight.LeftToSpendMidMonth)
    case leftToSpendNegativeSummary(TinkCore.ActionableInsight.LeftToSpendNegativeSummary)
    case budgetSuggestCreateTopCategory(TinkCore.ActionableInsight.BudgetSuggestCreateTopCategory)
    case budgetSuggestCreateTopPrimaryCategory(TinkCore.ActionableInsight.BudgetSuggestCreateTopCategory)
    case budgetSuggestCreateFirst
    case leftToSpendPositiveBeginningMonth(TinkCore.ActionableInsight.LeftToSpendBeginningMonth)
    case leftToSpendNegativeBeginningMonth(TinkCore.ActionableInsight.LeftToSpendBeginningMonth)
    case leftToSpendNegative(TinkCore.ActionableInsight.LeftToSpendNegative)
    case spendingByCategoryIncreased(TinkCore.ActionableInsight.SpendingByCategoryIncreased)
    case spendingByPrimaryCategoryIncreased(TinkCore.ActionableInsight.SpendingByCategoryIncreased)
    case leftToSpendPositiveSummarySavingsAccount(TinkCore.ActionableInsight.LeftToSpendPositiveSummarySavingsAccount)
    case leftToSpendPositiveFinalWeek(TinkCore.ActionableInsight.LeftToSpendPositiveFinalWeek)
    case aggregationRefreshPSD2Credentials(TinkCore.ActionableInsight.AggregationRefreshPSD2Credentials)
    case unknown
  }
  public let id: TinkCore.ActionableInsight.ID
  public let kind: TinkCore.ActionableInsight.Kind
  public let state: TinkCore.ActionableInsight.State
  public let title: Swift.String
  public let description: Swift.String
  public let created: Foundation.Date
}
extension TinkCore.ActionableInsight {
  public struct AccountBalanceLowData {
    public let accountID: TinkCore.Account.ID
    public let balance: TinkCore.CurrencyDenominatedAmount
  }
  public struct BudgetSummary {
    public let budgetID: TinkCore.Budget.ID
    public let budgetPeriod: TinkCore.ActionableInsight.BudgetPeriod
  }
  public struct BudgetPeriod {
    public let dateInterval: Foundation.DateInterval
    public let spentAmount: TinkCore.CurrencyDenominatedAmount
    public let budgetAmount: TinkCore.CurrencyDenominatedAmount
  }
  public enum BudgetPeriodUnit {
    case year
    case month
    case week
    case unspecified
    public static func == (a: TinkCore.ActionableInsight.BudgetPeriodUnit, b: TinkCore.ActionableInsight.BudgetPeriodUnit) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct BudgetPeriodSummary {
    public let achievedBudgets: [TinkCore.ActionableInsight.BudgetSummary]
    public let overspentBudgets: [TinkCore.ActionableInsight.BudgetSummary]
    public let periodUnit: TinkCore.ActionableInsight.BudgetPeriodUnit
  }
  public struct LargeExpense {
    public let transactionID: TinkCore.Transaction.ID
    public let amount: TinkCore.CurrencyDenominatedAmount
  }
  public struct WeeklyTransactions {
    public let transactionIDs: [TinkCore.Transaction.ID]
    public let week: TinkCore.ActionableInsight.Week
  }
  public struct CategorySpending {
    public let categoryCode: TinkCore.Category.Code
    public let spentAmount: TinkCore.CurrencyDenominatedAmount
  }
  public struct TransactionSummary {
    public struct TransactionsOverview {
      public let totalCount: Swift.Int
      public let mostCommonDescription: Swift.String
      public let mostCommonCount: Swift.Int
    }
    public struct LargestExpense {
      public let id: TinkCore.Transaction.ID
      public let date: Foundation.Date
      public let amount: TinkCore.CurrencyDenominatedAmount
      public let description: Swift.String
    }
    public let totalExpenses: TinkCore.CurrencyDenominatedAmount
    public let commonTransactionsOverview: TinkCore.ActionableInsight.TransactionSummary.TransactionsOverview
    public let largestExpense: TinkCore.ActionableInsight.TransactionSummary.LargestExpense
  }
  public struct WeeklyExpensesByCategory {
    public let week: TinkCore.ActionableInsight.Week
    public let expensesByCategory: [TinkCore.ActionableInsight.CategorySpending]
  }
  public struct WeeklyExpensesByDay {
    public struct ExpenseStatisticsByDay {
      public let day: TinkCore.ActionableInsight.Day
      public let expenseStatistics: TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatistics
    }
    public struct ExpenseStatistics {
      public let totalAmount: TinkCore.CurrencyDenominatedAmount
      public let averageAmount: TinkCore.CurrencyDenominatedAmount
    }
    public let week: TinkCore.ActionableInsight.Week
    public let expenseStatisticsByDay: [TinkCore.ActionableInsight.WeeklyExpensesByDay.ExpenseStatisticsByDay]
  }
  public struct WeeklyTransactionsSummary {
    public let week: TinkCore.ActionableInsight.Week
    public let summary: TinkCore.ActionableInsight.TransactionSummary
  }
  public struct MonthlyExpensesByCategory {
    public let month: TinkCore.ActionableInsight.Month
    public let expensesByCategory: [TinkCore.ActionableInsight.CategorySpending]
  }
  public struct NewIncomeTransaction {
    public let transactionID: TinkCore.Transaction.ID
    public let accountID: TinkCore.Account.ID
  }
  public struct MonthlyTransactionsSummary {
    public let month: TinkCore.ActionableInsight.Month
    public let summary: TinkCore.ActionableInsight.TransactionSummary
  }
  public struct Month {
    public let year: Swift.Int
    public let month: Swift.Int
  }
  public struct Week {
    public let year: Swift.Int
    public let week: Swift.Int
  }
  public struct Day {
    public let year: Swift.Int
    public let month: Swift.Int
    public let day: Swift.Int
  }
  public struct AccountInfo {
    public let id: TinkCore.Account.ID
    public let name: Swift.String
  }
  public struct SuggestSetUpSavingsAccount {
    public let balance: TinkCore.CurrencyDenominatedAmount
    public let savingsAccount: TinkCore.ActionableInsight.AccountInfo
    public let currentAccount: TinkCore.ActionableInsight.AccountInfo
  }
  public struct CreditCardLimit {
    public let account: TinkCore.ActionableInsight.AccountInfo
    public let availableCredit: TinkCore.CurrencyDenominatedAmount?
  }
  public struct LeftToSpendStatistics {
    public let createdAt: Foundation.Date
    public let currentLeftToSpend: TinkCore.CurrencyDenominatedAmount
    public let averageLeftToSpend: TinkCore.CurrencyDenominatedAmount
  }
  public struct LeftToSpendMidMonth {
    public let month: TinkCore.ActionableInsight.Month
    public let amountDifference: TinkCore.CurrencyDenominatedAmount
    public let leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics
  }
  public struct LeftToSpendNegativeSummary {
    public let month: TinkCore.ActionableInsight.Month
    public let leftToSpend: TinkCore.CurrencyDenominatedAmount
  }
  public struct BudgetSuggestCreateTopCategory {
    public let categorySpending: TinkCore.ActionableInsight.CategorySpending
    public let suggestedBudgetAmount: TinkCore.CurrencyDenominatedAmount
    public let suggestedBudgetCategoryDisplayName: Swift.String
  }
  public struct LeftToSpendBeginningMonth {
    public let month: TinkCore.ActionableInsight.Month
    public let amountDifference: TinkCore.CurrencyDenominatedAmount
    public let totalExpense: TinkCore.CurrencyDenominatedAmount
    public let leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics
  }
  public struct LeftToSpendNegative {
    public let month: TinkCore.ActionableInsight.Month
    public let createdAt: Foundation.Date
    public let leftToSpend: TinkCore.CurrencyDenominatedAmount
  }
  public struct CategoryInfo {
    public let id: TinkCore.Category.ID
    public let code: TinkCore.Category.Code
    public let name: Swift.String
  }
  public struct SpendingByCategoryIncreased {
    public let category: TinkCore.ActionableInsight.CategoryInfo
    public let lastMonth: TinkCore.ActionableInsight.Month
    public let lastMonthSpending: TinkCore.CurrencyDenominatedAmount
    public let twoMonthsAgoSpending: TinkCore.CurrencyDenominatedAmount
    public let percentage: Swift.Double
  }
  public struct LeftToSpendPositiveSummarySavingsAccount {
    public let month: TinkCore.ActionableInsight.Month
    public let leftAmount: TinkCore.CurrencyDenominatedAmount
  }
  public struct LeftToSpendPositiveFinalWeek {
    public let month: TinkCore.ActionableInsight.Month
    public let amountDifference: TinkCore.CurrencyDenominatedAmount
    public let leftToSpendStatistics: TinkCore.ActionableInsight.LeftToSpendStatistics
    public let leftToSpendPerDay: TinkCore.CurrencyDenominatedAmount
  }
  public struct ProviderInfo {
    public let id: TinkCore.Provider.ID
    public let displayName: Swift.String
  }
  public struct AggregationRefreshPSD2Credentials {
    public let credentialsID: TinkCore.Credentials.ID
    public let provider: TinkCore.ActionableInsight.ProviderInfo
    public let sessionExpiryDate: Foundation.Date
  }
}
public enum InsightActionData {
  public struct ViewBudget {
    public let budgetID: TinkCore.Budget.ID
    public let budgetPeriodStartTime: Foundation.Date
  }
  public struct CreateTransfer {
    public let sourceAccount: Foundation.URL?
    public let destinationAccount: Foundation.URL?
    public let amount: TinkCore.CurrencyDenominatedAmount?
    public let sourceAccountNumber: Swift.String?
    public let destinationAccountNumber: Swift.String?
  }
  public struct ViewTransaction {
    public let transactionID: TinkCore.Transaction.ID
  }
  public struct CategorizeSingleExpense {
    public let transactionID: TinkCore.Transaction.ID
  }
  public struct ViewTransactions {
    public let transactionIDs: [TinkCore.Transaction.ID]
  }
  public struct CategorizeTransactions {
    public let transactionIDs: [TinkCore.Transaction.ID]
  }
  public struct ViewTransactionsByCategory {
    public let transactionIdsByCategory: [TinkCore.Category.Code : [TinkCore.Transaction.ID]]
  }
  public struct BudgetSuggestion {
    public let filters: [TinkCore.Budget.Filter]
    public let amount: TinkCore.CurrencyDenominatedAmount?
    public let periodicity: TinkCore.Budget.Periodicity?
  }
  case unknown
  case acknowledge
  case dismiss
  case viewBudget(TinkCore.InsightActionData.ViewBudget)
  case createTransfer(TinkCore.InsightActionData.CreateTransfer)
  case viewTransaction(TinkCore.Transaction.ID)
  case categorizeExpense(TinkCore.Transaction.ID)
  case viewTransactions([TinkCore.Transaction.ID])
  case categorizeTransactions([TinkCore.Transaction.ID])
  case viewTransactionsByCategory([TinkCore.Category.Code : [TinkCore.Transaction.ID]])
  case viewAccount(TinkCore.Account.ID)
  case viewLeftToSpend(TinkCore.ActionableInsight.Month)
  case createBudget(TinkCore.InsightActionData.BudgetSuggestion)
  case refreshCredentials(TinkCore.Credentials.ID)
}
public protocol ActionableInsightService {
  func insights(completion: @escaping (Swift.Result<[TinkCore.ActionableInsight], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func archivedInsights(completion: @escaping (Swift.Result<[TinkCore.ActionableInsight], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func select(_ insightAction: TinkCore.ActionableInsight.InsightAction, forInsightWithID insightID: TinkCore.ActionableInsight.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public protocol AuthenticationService {
  func clientDescription(clientID: Swift.String, scopes: [TinkCore.Scope], redirectURI: Foundation.URL, completion: @escaping (Swift.Result<TinkCore.ClientDescription, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authorize(clientID: Swift.String, redirectURI: Foundation.URL, scopes: [TinkCore.Scope], completion: @escaping (Swift.Result<TinkCore.AuthorizationCode, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct AuthorizationCode : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(_ value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct Budget {
  public typealias ID = TinkCore.Identifier<TinkCore.Budget>
  public enum Periodicity : Swift.Equatable {
    case oneOff(TinkCore.Budget.OneOffPeriodicity)
    case recurring(TinkCore.Budget.RecurringPeriodicity)
    public static func == (a: TinkCore.Budget.Periodicity, b: TinkCore.Budget.Periodicity) -> Swift.Bool
  }
  public struct RecurringPeriodicity : Swift.Equatable {
    public enum PeriodUnit {
      case week
      case month
      case year
      public static func == (a: TinkCore.Budget.RecurringPeriodicity.PeriodUnit, b: TinkCore.Budget.RecurringPeriodicity.PeriodUnit) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public let periodUnit: TinkCore.Budget.RecurringPeriodicity.PeriodUnit
    public init(periodUnit: TinkCore.Budget.RecurringPeriodicity.PeriodUnit)
    public static func == (a: TinkCore.Budget.RecurringPeriodicity, b: TinkCore.Budget.RecurringPeriodicity) -> Swift.Bool
  }
  public struct OneOffPeriodicity : Swift.Equatable {
    public let start: Foundation.Date
    public let end: Foundation.Date
    public init(start: Foundation.Date, end: Foundation.Date)
    public static func == (a: TinkCore.Budget.OneOffPeriodicity, b: TinkCore.Budget.OneOffPeriodicity) -> Swift.Bool
  }
  public enum Filter {
    case account(TinkCore.Account.ID)
    case category(TinkCore.Category.Code)
    case tag(Swift.String)
    case search(Swift.String)
  }
  public let id: TinkCore.Budget.ID
  public let name: Swift.String
  public let amount: TinkCore.CurrencyDenominatedAmount?
  public let filter: [TinkCore.Budget.Filter]
  public let periodicity: TinkCore.Budget.Periodicity?
  public let created: Foundation.Date?
}
extension TinkCore.Budget {
  public struct Transaction {
    public let id: TinkCore.Transaction.ID
    public let amount: TinkCore.CurrencyDenominatedAmount
    public let dispensableAmount: TinkCore.CurrencyDenominatedAmount?
    public let date: Foundation.Date?
    public let description: Swift.String?
    public let categoryCode: TinkCore.Category.Code?
    public let accountID: TinkCore.Account.ID?
    public let pending: Swift.Bool?
  }
}
public struct BudgetDetails {
  public let budgetSpecification: TinkCore.Budget
  public let budgetPeriods: [TinkCore.Budget.Period]
  public let dateInterval: Foundation.DateInterval
  public let totalSpentAmount: TinkCore.CurrencyDenominatedAmount?
  public let averageSpentAmount: TinkCore.CurrencyDenominatedAmount?
}
extension TinkCore.Budget {
  public struct Period : Swift.Equatable {
    public let dateInterval: Foundation.DateInterval
    public let spentAmount: TinkCore.CurrencyDenominatedAmount?
    public static func == (a: TinkCore.Budget.Period, b: TinkCore.Budget.Period) -> Swift.Bool
  }
}
public protocol BudgetService {
  func budgets(includeArchived: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Budget], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func create(name: Swift.String, amount: TinkCore.CurrencyDenominatedAmount, filter: [TinkCore.Budget.Filter], periodicity: TinkCore.Budget.Periodicity, completion: @escaping (Swift.Result<TinkCore.Budget, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func update(id: TinkCore.Budget.ID, name: Swift.String, amount: TinkCore.CurrencyDenominatedAmount, filter: [TinkCore.Budget.Filter], periodicity: TinkCore.Budget.Periodicity, completion: @escaping (Swift.Result<TinkCore.Budget, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func transactionsForBudget(id: TinkCore.Budget.ID, dateInterval: Foundation.DateInterval, completion: @escaping (Swift.Result<[TinkCore.Budget.Transaction], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func budgetSummaries(includeArchived: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.BudgetSummary], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func budgetDetails(id: TinkCore.Budget.ID, dateInterval: Foundation.DateInterval, completion: @escaping (Swift.Result<TinkCore.BudgetDetails, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func archive(id: TinkCore.Budget.ID, completion: @escaping (Swift.Result<TinkCore.Budget, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func recommendedBudgets(completion: @escaping (Swift.Result<[TinkCore.RecommendedBudget], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct BudgetSummary {
  public let budget: TinkCore.Budget
  public let budgetPeriod: TinkCore.Budget.Period
}
public protocol CalendarService {
  func period(period: Swift.String, completion: @escaping (Swift.Result<[TinkCore.Period], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public protocol Cancellable {
  func cancel()
}
public struct Category : Swift.Equatable {
  public typealias ID = TinkCore.Identifier<TinkCore.Category>
  public let id: TinkCore.Category.ID
  public let code: TinkCore.Category.Code
  public let name: Swift.String
  public let sortOrder: Swift.Int
  public let parent: TinkCore.Category.ID?
  public static func == (a: TinkCore.Category, b: TinkCore.Category) -> Swift.Bool
}
extension TinkCore.Category {
  public struct Code : Swift.Hashable, Swift.ExpressibleByStringLiteral {
    public let value: Swift.String
    public init(_ value: Swift.String)
    public init(stringLiteral value: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TinkCore.Category.Code, b: TinkCore.Category.Code) -> Swift.Bool
    public typealias ExtendedGraphemeClusterLiteralType = Swift.String
    public typealias StringLiteralType = Swift.String
    public typealias UnicodeScalarLiteralType = Swift.String
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension TinkCore.Category.Code {
  public var isExpense: Swift.Bool {
    get
  }
  public var isIncome: Swift.Bool {
    get
  }
  public var isTransfer: Swift.Bool {
    get
  }
  public var type: TinkCore.Category.Kind {
    get
  }
  public var isUncategorized: Swift.Bool {
    get
  }
  public var isReimbursement: Swift.Bool {
    get
  }
  public var isSavings: Swift.Bool {
    get
  }
  public var isExcluded: Swift.Bool {
    get
  }
  public var isOther: Swift.Bool {
    get
  }
  public var isMiscOther: Swift.Bool {
    get
  }
  public var isExpensesOther: Swift.Bool {
    get
  }
  public var isRootCategory: Swift.Bool {
    get
  }
  public var isSubcategory: Swift.Bool {
    get
  }
  public func isChild(of parent: TinkCore.Category.Code) -> Swift.Bool
}
extension TinkCore.Category {
  public enum Kind : Swift.String, Swift.Hashable {
    case expenses
    case income
    case transfers
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
extension TinkCore.Category.Kind {
  public init(code: TinkCore.Category.Code)
  public var categoryCode: TinkCore.Category.Code {
    get
  }
}
public protocol CategoryService {
  func categories(completion: @escaping (Swift.Result<[TinkCore.Category], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct ClientDescription {
  public let name: Swift.String
  public let scopes: [TinkCore.ScopeDescription]
  public let isVerified: Swift.Bool
  public let isAggregator: Swift.Bool
}
public protocol Configuration {
  var clientID: Swift.String { get }
  var appURI: Foundation.URL? { get }
  var callbackURI: Foundation.URL? { get }
  var environment: TinkCore.Tink.Environment { get }
  var certificateURL: Foundation.URL? { get }
}
extension TinkCore.Tink {
  public struct Configuration : TinkCore.Configuration {
    public var clientID: Swift.String
    public var redirectURI: Foundation.URL
    public var appURI: Foundation.URL?
    public var callbackURI: Foundation.URL?
    public var environment: TinkCore.Tink.Environment
    public var certificateURL: Foundation.URL?
    @available(*, renamed: "certificateURL")
    public var restCertificateURL: Foundation.URL? {
      get
    }
    public init(clientID: Swift.String, appURI: Foundation.URL? = nil, environment: TinkCore.Tink.Environment = .production, certificateURL: Foundation.URL? = nil)
    public init(clientID: Swift.String, redirectURI: Foundation.URL, environment: TinkCore.Tink.Environment = .production, certificateURL: Foundation.URL? = nil) throws
  }
}
public struct Credentials : Swift.Identifiable {
  public typealias ID = TinkCore.Identifier<TinkCore.Credentials>
  public let id: TinkCore.Credentials.ID
  public let providerName: TinkCore.Provider.Name
  public enum Kind {
    case unknown
    case password
    case mobileBankID
    case keyfob
    case thirdPartyAuthentication
    public var sortOrder: Swift.Int {
      get
    }
    public static func == (a: TinkCore.Credentials.Kind, b: TinkCore.Credentials.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let kind: TinkCore.Credentials.Kind
  public enum Status : Swift.Equatable {
    case unknown
    case created
    case authenticating
    case updating
    case updated
    case temporaryError
    case authenticationError
    case permanentError
    case awaitingMobileBankIDAuthentication(TinkCore.Credentials.ThirdPartyAppAuthentication)
    case awaitingSupplementalInformation([TinkCore.Provider.Field])
    case deleted
    case awaitingThirdPartyAppAuthentication(TinkCore.Credentials.ThirdPartyAppAuthentication)
    case sessionExpired
    public static func == (a: TinkCore.Credentials.Status, b: TinkCore.Credentials.Status) -> Swift.Bool
  }
  public let status: TinkCore.Credentials.Status
  public let statusPayload: Swift.String?
  public let statusUpdated: Foundation.Date?
  public let updated: Foundation.Date?
  public let fields: [Swift.String : Swift.String]
  public struct ThirdPartyAppAuthentication : Swift.Equatable {
    public let downloadTitle: Swift.String?
    public let downloadMessage: Swift.String?
    public let upgradeTitle: Swift.String?
    public let upgradeMessage: Swift.String?
    public let appStoreURL: Foundation.URL?
    public let scheme: Swift.String?
    public let deepLinkURL: Foundation.URL?
    public var hasAutoStartToken: Swift.Bool {
      get
    }
    public static func == (a: TinkCore.Credentials.ThirdPartyAppAuthentication, b: TinkCore.Credentials.ThirdPartyAppAuthentication) -> Swift.Bool
  }
  public let sessionExpiryDate: Foundation.Date?
  public var hasError: Swift.Bool {
    get
  }
}
public protocol CredentialsService {
  func credentialsList(completion: @escaping (Swift.Result<[TinkCore.Credentials], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func credentials(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func create(providerName: TinkCore.Provider.Name, refreshableItems: TinkCore.RefreshableItems, fields: [Swift.String : Swift.String], appURI: Foundation.URL?, callbackURI: Foundation.URL?, completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func create(providerName: TinkCore.Provider.Name, refreshableItems: TinkCore.RefreshableItems, fields: [Swift.String : Swift.String], appURI: Foundation.URL?, callbackURI: Foundation.URL?, products: [TinkCore.Product], completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func delete(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func update(id: TinkCore.Credentials.ID, providerName: TinkCore.Provider.Name, appURI: Foundation.URL?, callbackURI: Foundation.URL?, fields: [Swift.String : Swift.String], completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func update(id: TinkCore.Credentials.ID, providerName: TinkCore.Provider.Name, appURI: Foundation.URL?, callbackURI: Foundation.URL?, fields: [Swift.String : Swift.String], products: [TinkCore.Product], completion: @escaping (Swift.Result<TinkCore.Credentials, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func refresh(id: TinkCore.Credentials.ID, authenticate: Swift.Bool, refreshableItems: TinkCore.RefreshableItems, appURI: Foundation.URL?, callbackURI: Foundation.URL?, optIn: Swift.Bool, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func refresh(id: TinkCore.Credentials.ID, authenticate: Swift.Bool, refreshableItems: TinkCore.RefreshableItems, appURI: Foundation.URL?, callbackURI: Foundation.URL?, optIn: Swift.Bool, products: [TinkCore.Product], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func addSupplementalInformation(id: TinkCore.Credentials.ID, fields: [Swift.String : Swift.String], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func cancelSupplementalInformation(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func enable(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func disable(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func thirdPartyCallback(state: Swift.String, parameters: [Swift.String : Swift.String], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authenticate(id: TinkCore.Credentials.ID, appURI: Foundation.URL?, callbackURI: Foundation.URL?, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authenticate(id: TinkCore.Credentials.ID, appURI: Foundation.URL?, callbackURI: Foundation.URL?, products: [TinkCore.Product], completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func qrCode(id: TinkCore.Credentials.ID, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct CurrencyCode : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public let value: Swift.String
  public init(_ value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.CurrencyCode, b: TinkCore.CurrencyCode) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public struct CurrencyDenominatedAmount : Swift.Equatable, Swift.Hashable {
  public let value: Foundation.Decimal
  public let currencyCode: TinkCore.CurrencyCode
  public static func == (a: TinkCore.CurrencyDenominatedAmount, b: TinkCore.CurrencyDenominatedAmount) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension TinkCore.CurrencyDenominatedAmount {
  public var doubleValue: Swift.Double {
    get
  }
  public init()
  public init(_ int: Swift.Int, currencyCode: TinkCore.CurrencyCode)
  public init(_ double: Swift.Double, currencyCode: TinkCore.CurrencyCode)
  public init(_ decimal: Foundation.Decimal, currencyCode: TinkCore.CurrencyCode)
  public init(_ number: Foundation.NSNumber, currencyCode: TinkCore.CurrencyCode)
}
extension TinkCore.CurrencyDenominatedAmount {
  public static func + (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
  public static func - (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
  public static func * (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
  public static func / (lhs: TinkCore.CurrencyDenominatedAmount, rhs: TinkCore.CurrencyDenominatedAmount) -> TinkCore.CurrencyDenominatedAmount
}
extension TinkCore.Tink {
  public enum Environment {
    case production
    case custom(Foundation.URL)
  }
}
extension TinkCore.Provider {
  public struct FinancialInstitution : Swift.Hashable {
    public typealias ID = TinkCore.Identifier<TinkCore.Provider.FinancialInstitution>
    public let id: TinkCore.Provider.FinancialInstitution.ID
    public let name: Swift.String
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: TinkCore.Provider.FinancialInstitution, b: TinkCore.Provider.FinancialInstitution) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public struct Identifier<Type> : Swift.Hashable, Swift.ExpressibleByStringLiteral {
  public let value: Swift.String
  public init(_ value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.Identifier<Type>, b: TinkCore.Identifier<Type>) -> Swift.Bool
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
extension TinkCore.Tink {
  public static var availableLocales: [Foundation.Locale] {
    get
  }
  public static var defaultLocale: Foundation.Locale {
    get
  }
}
public struct Market : Swift.Hashable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(code value: Swift.String)
  public var code: Swift.String {
    get
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension TinkCore.Market : Swift.Comparable {
  public static func < (lhs: TinkCore.Market, rhs: TinkCore.Market) -> Swift.Bool
}
public protocol OAuthService {
  func createAnonymous(market: TinkCore.Market?, locale: Foundation.Locale, origin: Swift.String?, completion: @escaping (Swift.Result<TinkCore.AccessToken, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func authenticate(clientID: Swift.String, code: TinkCore.AuthorizationCode, completion: @escaping (Swift.Result<TinkCore.AccessToken, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct Period {
  public enum Resolution {
    case monthly
    case monthlyAdjusted
    public static func == (a: TinkCore.Period.Resolution, b: TinkCore.Period.Resolution) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let dateInterval: Foundation.DateInterval
  public let name: Swift.String
  public let resolution: TinkCore.Period.Resolution
}
extension TinkCore.Period.Resolution {
  public var statisticResolution: TinkCore.Statistic.Resolution {
    get
  }
}
public enum Product {
  case realTimeBalance
  case paymentInitiation
  case accountAggregation
  case accountCheck
  case incomeCheck
  case moneyManager
  case transactions
  case businessTransactions
  case riskInsights
  public static func == (a: TinkCore.Product, b: TinkCore.Product) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Provider : Swift.Identifiable {
  public typealias Name = TinkCore.Identifier<TinkCore.Provider>
  public var id: TinkCore.Provider.Name {
    get
  }
  public let name: TinkCore.Provider.Name
  public let displayName: Swift.String
  public struct FinancialService : Swift.Equatable, Swift.Hashable {
    public enum Segment {
      case personal
      case business
      case unknown
      public static func == (a: TinkCore.Provider.FinancialService.Segment, b: TinkCore.Provider.FinancialService.Segment) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public let segment: TinkCore.Provider.FinancialService.Segment
    public let shortName: Swift.String
    public static func == (a: TinkCore.Provider.FinancialService, b: TinkCore.Provider.FinancialService) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let financialServices: [TinkCore.Provider.FinancialService]
  public enum Kind {
    case unknown
    case bank
    case creditCard
    case broker
    case other
    case test
    public static var `default`: Swift.Set<TinkCore.Provider.Kind>
    public static var onlyTest: Swift.Set<TinkCore.Provider.Kind>
    public static var all: Swift.Set<TinkCore.Provider.Kind>
    public static func == (a: TinkCore.Provider.Kind, b: TinkCore.Provider.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let kind: TinkCore.Provider.Kind
  public enum ReleaseStatus {
    case beta
    public static func == (a: TinkCore.Provider.ReleaseStatus, b: TinkCore.Provider.ReleaseStatus) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let releaseStatus: TinkCore.Provider.ReleaseStatus?
  public enum Status {
    case unknown
    case enabled
    case disabled
    case temporaryDisabled
    public static func == (a: TinkCore.Provider.Status, b: TinkCore.Provider.Status) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let status: TinkCore.Provider.Status
  public let credentialsKind: TinkCore.Credentials.Kind
  public let helpText: Swift.String?
  public let isPopular: Swift.Bool
  public struct Field : Swift.Equatable {
    public let description: Swift.String?
    public let hint: Swift.String?
    public let maxLength: Swift.Int?
    public let minLength: Swift.Int?
    public let isMasked: Swift.Bool
    public let isNumeric: Swift.Bool
    public let isImmutable: Swift.Bool
    public let isOptional: Swift.Bool
    public let name: Swift.String
    public let initialValue: Swift.String
    public let pattern: Swift.String
    public let patternError: Swift.String
    public let helpText: Swift.String
    public let selectOptions: [TinkCore.SelectOption]
    public mutating func setImmutable(initialValue newValue: Swift.String)
    public static func == (a: TinkCore.Provider.Field, b: TinkCore.Provider.Field) -> Swift.Bool
  }
  public let fields: [TinkCore.Provider.Field]
  public let groupDisplayName: Swift.String
  public let image: Foundation.URL?
  public let displayDescription: Swift.String
  public struct Capabilities : Swift.OptionSet, Swift.Hashable {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let transfers: TinkCore.Provider.Capabilities
    public static let mortgageAggregation: TinkCore.Provider.Capabilities
    public static let checkingAccounts: TinkCore.Provider.Capabilities
    public static let savingsAccounts: TinkCore.Provider.Capabilities
    public static let creditCards: TinkCore.Provider.Capabilities
    public static let investments: TinkCore.Provider.Capabilities
    public static let loans: TinkCore.Provider.Capabilities
    public static let payments: TinkCore.Provider.Capabilities
    public static let mortgageLoan: TinkCore.Provider.Capabilities
    public static let identityData: TinkCore.Provider.Capabilities
    public static let eInvoices: TinkCore.Provider.Capabilities
    public static let listBeneficiaries: TinkCore.Provider.Capabilities
    public static let createBeneficiaries: TinkCore.Provider.Capabilities
    public static let all: TinkCore.Provider.Capabilities
    public typealias ArrayLiteralElement = TinkCore.Provider.Capabilities
    public typealias Element = TinkCore.Provider.Capabilities
    public typealias RawValue = Swift.Int
  }
  public let capabilities: TinkCore.Provider.Capabilities
  public enum AccessType : Swift.Hashable {
    case unknown
    case openBanking
    case other
    public static let all: Swift.Set<TinkCore.Provider.AccessType>
    public static func == (a: TinkCore.Provider.AccessType, b: TinkCore.Provider.AccessType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let accessType: TinkCore.Provider.AccessType
  public let marketCode: Swift.String
  public let financialInstitution: TinkCore.Provider.FinancialInstitution
  public typealias ID = TinkCore.Provider.Name
}
extension Swift.Set where Element == TinkCore.Provider.Kind {
  public static var all: Swift.Set<TinkCore.Provider.Kind> {
    get
  }
  public static var `default`: Swift.Set<TinkCore.Provider.Kind> {
    get
  }
  public static var onlyTest: Swift.Set<TinkCore.Provider.Kind> {
    get
  }
}
extension Swift.Set where Element == TinkCore.Provider.AccessType {
  public static var all: Swift.Set<TinkCore.Provider.AccessType> {
    get
  }
}
public protocol ProviderService {
  func providers(name: TinkCore.Provider.Name?, capabilities: TinkCore.Provider.Capabilities?, includeTestProviders: Swift.Bool, excludeNonTestProviders: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Provider], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func providers(market: TinkCore.Market, capabilities: TinkCore.Provider.Capabilities?, includeTestProviders: Swift.Bool, excludeNonTestProviders: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Provider], Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public struct RecommendedBudget {
  public let amount: TinkCore.CurrencyDenominatedAmount?
  public let filter: [TinkCore.Budget.Filter]
  public let name: Swift.String
  public let recurringPeriodicity: TinkCore.Budget.RecurringPeriodicity?
}
public struct RefreshableItems : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public static let checkingAccounts: TinkCore.RefreshableItems
  public static let checkingTransactions: TinkCore.RefreshableItems
  public static let savingAccounts: TinkCore.RefreshableItems
  public static let savingTransactions: TinkCore.RefreshableItems
  public static let creditCardAccounts: TinkCore.RefreshableItems
  public static let creditCardTransactions: TinkCore.RefreshableItems
  public static let loanAccounts: TinkCore.RefreshableItems
  public static let loanTransactions: TinkCore.RefreshableItems
  public static let investmentAccounts: TinkCore.RefreshableItems
  public static let investmentTransactions: TinkCore.RefreshableItems
  public static let eInvoices: TinkCore.RefreshableItems
  public static let transferDestinations: TinkCore.RefreshableItems
  public static let identityData: TinkCore.RefreshableItems
  public static let accounts: TinkCore.RefreshableItems
  public static let transactions: TinkCore.RefreshableItems
  public static let connectAccounts: TinkCore.RefreshableItems
  public static let all: TinkCore.RefreshableItems
  public typealias ArrayLiteralElement = TinkCore.RefreshableItems
  public typealias Element = TinkCore.RefreshableItems
  public typealias RawValue = Swift.Int
}
extension TinkCore.RefreshableItems {
  public init(providerCapabilities: TinkCore.Provider.Capabilities)
  public func supporting(providerCapabilities: TinkCore.Provider.Capabilities) -> TinkCore.RefreshableItems
}
public protocol Retriable {
  func retry()
}
public typealias RetryCancellable = (TinkCore.Cancellable & TinkCore.Retriable)
public struct Scope {
}
extension TinkCore.Scope : Swift.Equatable {
  public static func == (a: TinkCore.Scope, b: TinkCore.Scope) -> Swift.Bool
}
extension TinkCore.Scope {
  public enum ReadAccess : Swift.String {
    case read
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ReadWriteAccess : Swift.String {
    case read, write
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum AuthorizationAccess : Swift.String {
    case grant, read, revoke
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CredentialsAccess : Swift.String {
    case read, write, refresh
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransactionAccess : Swift.String {
    case read, write, categorize
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransferAccess : Swift.String {
    case read, execute
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum UserAccess : Swift.String {
    case create, delete, read, webHooks, write
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static func accounts(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func activities(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func authorization(_ access: TinkCore.Scope.AuthorizationAccess...) -> TinkCore.Scope
  public static func balances(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func beneficiaries(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func budgets(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func calendar(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func categories(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func contacts(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func credentials(_ access: TinkCore.Scope.CredentialsAccess...) -> TinkCore.Scope
  public static func dataExports(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func documents(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func follow(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func identity(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func insights(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func investments(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func properties(_ access: TinkCore.Scope.ReadWriteAccess...) -> TinkCore.Scope
  public static func providers(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func statistics(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func suggestions(_ access: TinkCore.Scope.ReadAccess...) -> TinkCore.Scope
  public static func transactions(_ access: TinkCore.Scope.TransactionAccess...) -> TinkCore.Scope
  public static func transfer(_ access: TinkCore.Scope.TransferAccess...) -> TinkCore.Scope
  public static func user(_ access: TinkCore.Scope.UserAccess...) -> TinkCore.Scope
}
public struct ScopeDescription {
  public let title: Swift.String
  public let description: Swift.String
}
public struct SelectOption : Swift.Equatable {
  public let iconURL: Foundation.URL?
  public let text: Swift.String?
  public let value: Swift.String?
  public static func == (a: TinkCore.SelectOption, b: TinkCore.SelectOption) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class ServiceContainer {
  final public var authenticationService: TinkCore.AuthenticationService {
    get
  }
  final public var oAuthService: TinkCore.OAuthService {
    get
  }
  final public var credentialsService: TinkCore.CredentialsService {
    get
  }
  final public var providerService: TinkCore.ProviderService {
    get
  }
  final public var userService: TinkCore.UserService {
    get
  }
  final public var accountService: TinkCore.AccountService {
    get
  }
  final public var actionableInsightService: TinkCore.ActionableInsightService {
    get
  }
  final public var budgetService: TinkCore.BudgetService {
    get
  }
  final public var calendarService: TinkCore.CalendarService {
    get
  }
  final public var categoryService: TinkCore.CategoryService {
    get
  }
  final public var statisticService: TinkCore.StatisticService {
    get
  }
  final public var transactionService: TinkCore.TransactionService {
    get
  }
  @objc deinit
}
public enum ServiceError : Swift.Error {
  case cancelled
  case invalidArgument(Swift.String?)
  case notFound(Swift.String?)
  case alreadyExists(Swift.String?)
  case permissionDenied(Swift.String?)
  case unauthenticated(Swift.String?)
  case failedPrecondition(Swift.String?)
  case tooManyRequests(Swift.String?)
  case unavailableForLegalReasons(Swift.String?)
  case internalError(Swift.String?)
}
public protocol SessionManager {
}
public struct SessionUser {
  public var username: Swift.String? {
    get
  }
}
public struct Statistic {
  public enum Resolution {
    case daily, monthly, monthlyAdjusted, yearly, all, weekly
    public static func == (a: TinkCore.Statistic.Resolution, b: TinkCore.Statistic.Resolution) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Kind {
    case balancesByAccount
    case balancesByAccountTypeGroup
    case expensesByCategory
    case expensesByPrimaryCategory
    case expensesByCategoryByCount
    case expensesByPrimaryCategoryByCount
    case incomeByCategory
    case incomeAndExpenses
    case leftToSpend
    case leftToSpendAverage
    public static func == (a: TinkCore.Statistic.Kind, b: TinkCore.Statistic.Kind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let description: Swift.String
  public let payload: Swift.String?
  public let period: TinkCore.StatisticPeriod
  public let resolution: TinkCore.Statistic.Resolution
  public let kind: TinkCore.Statistic.Kind
  public let value: Swift.Double
  public let userID: Swift.String
}
public enum StatisticPeriod : Swift.Hashable {
  case year(Swift.Int)
  case week(year: Swift.Int, week: Swift.Int)
  case month(year: Swift.Int, month: Swift.Int)
  case day(year: Swift.Int, month: Swift.Int, day: Swift.Int)
  public var stringRepresentation: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.StatisticPeriod, b: TinkCore.StatisticPeriod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol StatisticService {
  func statistics(description: Swift.String?, periods: [TinkCore.StatisticPeriod], types: [TinkCore.Statistic.Kind], resolution: TinkCore.Statistic.Resolution, padResultsUntilToday: Swift.Bool, completion: @escaping (Swift.Result<[TinkCore.Statistic], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
@available(*, deprecated)
public struct SuggestTransactionsResponse {
  public let categorizationImprovement: Swift.Double
  public let categorizationLevel: Swift.Double
  public let clusters: [TinkCore.TransactionCluster]
}
extension TinkCore.Tink {
  @discardableResult
  public func _createTemporaryUser(for market: TinkCore.Market, locale: Foundation.Locale = Tink.defaultLocale, completion: @escaping (Swift.Result<TinkCore.AccessToken, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  public var _sdkName: Swift.String {
    get
    set
  }
  public var _version: Swift.String {
    get
    set
  }
  public var _urlSession: Foundation.URLSession {
    get
    set
  }
}
public let version: Swift.String
public class Tink {
  public static var shared: TinkCore.Tink {
    get
  }
  public var sessionManagers: [TinkCore.SessionManager]
  public var userSession: TinkCore.UserSession? {
    get
    set
  }
  public init(configuration: TinkCore.Configuration)
  public static func configure(with configuration: TinkCore.Configuration)
  final public let configuration: TinkCore.Configuration
  public var services: TinkCore.ServiceContainer {
    get
  }
  @objc deinit
}
extension TinkCore.Tink {
  @discardableResult
  public func authenticateUser(authorizationCode: TinkCore.AuthorizationCode, completion: @escaping (Swift.Result<TinkCore.AccessToken, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public enum TinkLogger {
  public static func logUsedSDK(version: Swift.String, subsystem: Swift.String, category: Swift.String)
}
public struct Transaction {
  public typealias ID = TinkCore.Identifier<TinkCore.Transaction>
  public let accountID: TinkCore.Account.ID
  public let amount: TinkCore.CurrencyDenominatedAmount
  public var categoryID: TinkCore.Category.ID
  public let description: Swift.String
  public let date: Foundation.Date
  public let id: TinkCore.Transaction.ID
  public let inserted: Foundation.Date
  public let isUpcomingOrInFuture: Swift.Bool
  public let notes: Swift.String?
  public let originalDescription: Swift.String
  public let originalDate: Foundation.Date
  public let originalAmount: TinkCore.CurrencyDenominatedAmount
  public let isPending: Swift.Bool
  public let categoryType: TinkCore.CategoryType
  public let dispensableAmount: Swift.Double?
  public let lastModified: Foundation.Date
  public let type: TinkCore.TransactionType
  public let userId: Swift.String
  public init(id: TinkCore.Transaction.ID, accountID: TinkCore.Account.ID, amount: TinkCore.CurrencyDenominatedAmount, categoryID: TinkCore.Category.ID, description: Swift.String, date: Foundation.Date, inserted: Foundation.Date, isUpcomingOrInFuture: Swift.Bool, notes: Swift.String?, originalDescription: Swift.String, originalDate: Foundation.Date, originalAmount: TinkCore.CurrencyDenominatedAmount, isPending: Swift.Bool, categoryType: TinkCore.CategoryType, dispensableAmount: Swift.Double?, lastModified: Foundation.Date, type: TinkCore.TransactionType, userId: Swift.String)
}
extension TinkCore.Transaction : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: TinkCore.Transaction, b: TinkCore.Transaction) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum TransactionType {
  case `default`
  case creditCard
  case transfer
  case payment
  case withdrawal
  case unknown
  public static func == (a: TinkCore.TransactionType, b: TinkCore.TransactionType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CategoryType {
  case expenses
  case income
  case transfers
  case unknown
  public static func == (a: TinkCore.CategoryType, b: TinkCore.CategoryType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, deprecated)
public struct TransactionCluster {
  public let categorizationImprovement: Swift.Double
  public let description: Swift.String
  public let transactions: [TinkCore.Transaction]
}
public struct TransactionsQuery : Swift.Equatable {
  public var accountIDs: [TinkCore.Account.ID]
  public var categoryIDs: [TinkCore.Category.ID]
  public var dateInterval: Foundation.DateInterval?
  public var query: Swift.String?
  public var includeUpcoming: Swift.Bool
  public var sort: TinkCore.TransactionsQuery.Sort
  public var order: TinkCore.TransactionsQuery.Order
  public var limit: Swift.Int?
  public enum Sort : Swift.String {
    case date
    case account
    case description
    case amount
    case category
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @frozen public enum Order : Swift.String {
    case ascending
    case descending
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public init(accountIDs: [TinkCore.Account.ID] = [], categoryIDs: [TinkCore.Category.ID] = [], dateInterval: Foundation.DateInterval? = nil, query: Swift.String? = nil, includeUpcoming: Swift.Bool = false, sort: TinkCore.TransactionsQuery.Sort = .date, order: TinkCore.TransactionsQuery.Order = .descending, limit: Swift.Int? = nil)
  public static func == (a: TinkCore.TransactionsQuery, b: TinkCore.TransactionsQuery) -> Swift.Bool
}
public enum TransactionsQueryError : Swift.Error {
  case notMatchable
  public static func == (a: TinkCore.TransactionsQueryError, b: TinkCore.TransactionsQueryError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Collection where Self.Element == TinkCore.Transaction {
  public func filter(with query: TinkCore.TransactionsQuery) throws -> [TinkCore.Transaction]
}
public protocol TransactionService {
  func transactions(query: TinkCore.TransactionsQuery, offset: Swift.Int?, completion: @escaping (Swift.Result<([TinkCore.Transaction], Swift.Bool), Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func categorize(_ transactionIDs: [Swift.String], as newCategoryID: Swift.String, completion: @escaping (Swift.Result<Swift.Void, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func transactionsSimilar(to transactionID: Swift.String, ifCategorizedAs categoryID: Swift.String, completion: @escaping (Swift.Result<[TinkCore.Transaction], Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func transaction(id: TinkCore.Transaction.ID, completion: @escaping (Swift.Result<TinkCore.Transaction, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  func update(transactionID: TinkCore.Transaction.ID, amount: TinkCore.CurrencyDenominatedAmount, categoryID: TinkCore.Category.ID, date: Foundation.Date, description: Swift.String, notes: Swift.String?, completion: @escaping (Swift.Result<TinkCore.Transaction, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
  @available(*, deprecated)
  func suggestTransactions(numberOfClusters: Swift.Int?, evaluateEverything: Swift.Bool?, completion: @escaping (Swift.Result<TinkCore.SuggestTransactionsResponse, Swift.Error>) -> Swift.Void) -> TinkCore.Cancellable?
}
public struct User {
  public typealias ID = TinkCore.Identifier<TinkCore.User>
  public let created: Foundation.Date
  public let id: TinkCore.User.ID
  public let username: Swift.String?
  public let profile: TinkCore.UserProfile
}
public struct UserProfile {
  public let currency: TinkCore.CurrencyCode
  public let locale: Foundation.Locale
  public let market: TinkCore.Market
  public let periodAdjustedDay: Swift.Int
  public let periodMode: TinkCore.Period.Resolution?
  public let timeZone: Foundation.TimeZone?
}
public protocol UserService {
  func userProfile(completion: @escaping (Swift.Result<TinkCore.UserProfile, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
  func user(completion: @escaping (Swift.Result<TinkCore.User, Swift.Error>) -> Swift.Void) -> TinkCore.RetryCancellable?
}
public enum UserSession {
  case accessToken(Swift.String)
}
extension TinkCore.Account.Kind : Swift.Equatable {}
extension TinkCore.Account.Kind : Swift.Hashable {}
extension TinkCore.Account.AccountExclusion : Swift.Equatable {}
extension TinkCore.Account.AccountExclusion : Swift.Hashable {}
extension TinkCore.ActionableInsight.BudgetPeriodUnit : Swift.Equatable {}
extension TinkCore.ActionableInsight.BudgetPeriodUnit : Swift.Hashable {}
extension TinkCore.Budget.RecurringPeriodicity.PeriodUnit : Swift.Equatable {}
extension TinkCore.Budget.RecurringPeriodicity.PeriodUnit : Swift.Hashable {}
extension TinkCore.Category.Kind : Swift.RawRepresentable {}
extension TinkCore.Credentials.Kind : Swift.Equatable {}
extension TinkCore.Credentials.Kind : Swift.Hashable {}
extension TinkCore.Period.Resolution : Swift.Equatable {}
extension TinkCore.Period.Resolution : Swift.Hashable {}
extension TinkCore.Product : Swift.Equatable {}
extension TinkCore.Product : Swift.Hashable {}
extension TinkCore.Provider.Kind : Swift.Equatable {}
extension TinkCore.Provider.Kind : Swift.Hashable {}
extension TinkCore.Provider.Status : Swift.Equatable {}
extension TinkCore.Provider.Status : Swift.Hashable {}
extension TinkCore.Provider.FinancialService.Segment : Swift.Equatable {}
extension TinkCore.Provider.FinancialService.Segment : Swift.Hashable {}
extension TinkCore.Provider.ReleaseStatus : Swift.Equatable {}
extension TinkCore.Provider.ReleaseStatus : Swift.Hashable {}
extension TinkCore.Scope.ReadAccess : Swift.Equatable {}
extension TinkCore.Scope.ReadAccess : Swift.Hashable {}
extension TinkCore.Scope.ReadAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.ReadWriteAccess : Swift.Equatable {}
extension TinkCore.Scope.ReadWriteAccess : Swift.Hashable {}
extension TinkCore.Scope.ReadWriteAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.AuthorizationAccess : Swift.Equatable {}
extension TinkCore.Scope.AuthorizationAccess : Swift.Hashable {}
extension TinkCore.Scope.AuthorizationAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.CredentialsAccess : Swift.Equatable {}
extension TinkCore.Scope.CredentialsAccess : Swift.Hashable {}
extension TinkCore.Scope.CredentialsAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.TransactionAccess : Swift.Equatable {}
extension TinkCore.Scope.TransactionAccess : Swift.Hashable {}
extension TinkCore.Scope.TransactionAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.TransferAccess : Swift.Equatable {}
extension TinkCore.Scope.TransferAccess : Swift.Hashable {}
extension TinkCore.Scope.TransferAccess : Swift.RawRepresentable {}
extension TinkCore.Scope.UserAccess : Swift.Equatable {}
extension TinkCore.Scope.UserAccess : Swift.Hashable {}
extension TinkCore.Scope.UserAccess : Swift.RawRepresentable {}
extension TinkCore.Statistic.Kind : Swift.Equatable {}
extension TinkCore.Statistic.Kind : Swift.Hashable {}
extension TinkCore.Statistic.Resolution : Swift.Equatable {}
extension TinkCore.Statistic.Resolution : Swift.Hashable {}
extension TinkCore.TransactionType : Swift.Equatable {}
extension TinkCore.TransactionType : Swift.Hashable {}
extension TinkCore.CategoryType : Swift.Equatable {}
extension TinkCore.CategoryType : Swift.Hashable {}
extension TinkCore.TransactionsQuery.Sort : Swift.Equatable {}
extension TinkCore.TransactionsQuery.Sort : Swift.Hashable {}
extension TinkCore.TransactionsQuery.Sort : Swift.RawRepresentable {}
extension TinkCore.TransactionsQuery.Order : Swift.Equatable {}
extension TinkCore.TransactionsQuery.Order : Swift.Hashable {}
extension TinkCore.TransactionsQuery.Order : Swift.RawRepresentable {}
extension TinkCore.TransactionsQuery.Order : Swift.Sendable {}
extension TinkCore.TransactionsQueryError : Swift.Equatable {}
extension TinkCore.TransactionsQueryError : Swift.Hashable {}
